Author: Boris Komarov <boris.komarov@proton.me>
Date: Mon, 19 Jan 2026 19:58:08 +0100
Subject: [PATCH] Always use the current users password ($USER) and exported path for background image. Can be scaled to either fit screen, or fill it preserving aspect.

diff --git a/config.def.h b/config.def.h
index 9855e21..55191af 100644
--- a/config.def.h
+++ b/config.def.h
@@ -1,7 +1,3 @@
-/* user and group to drop privileges to */
-static const char *user  = "nobody";
-static const char *group = "nogroup";
-
 static const char *colorname[NUMCOLS] = {
 	[INIT] =   "black",     /* after initialization */
 	[INPUT] =  "#005577",   /* during input */
@@ -10,3 +6,8 @@ static const char *colorname[NUMCOLS] = {
 
 /* treat a cleared input like a wrong password (color) */
 static const int failonclear = 1;
+
+/* Background image */
+static const char* lockscreen_path = "WALLPAPER_PATH"; // env variable that slock is going to look for
+static const int image_mode = 1;  // 1 to fill, 0 to fit
+static const int blur_radius = 8; // Define blur radius
diff --git a/config.mk b/config.mk
index dcd27d0..04a4c85 100644
--- a/config.mk
+++ b/config.mk
@@ -12,7 +12,7 @@ X11LIB = /usr/X11R6/lib
 
 # includes and libs
 INCS = -I. -I/usr/include -I${X11INC}
-LIBS = -L/usr/lib -lc -lcrypt -L${X11LIB} -lX11 -lXext -lXrandr
+LIBS = -L/usr/lib -lc -lcrypt -L${X11LIB} -lX11 -lXext -lXrandr -lImlib2
 
 # flags
 CPPFLAGS = -DVERSION=\"${VERSION}\" -D_DEFAULT_SOURCE -DHAVE_SHADOW_H
diff --git a/slock.c b/slock.c
index b5a9b04..9d1b3cd 100644
--- a/slock.c
+++ b/slock.c
@@ -19,6 +19,7 @@
 #include <X11/keysym.h>
 #include <X11/Xlib.h>
 #include <X11/Xutil.h>
+#include <Imlib2.h>
 
 #include "arg.h"
 #include "util.h"
@@ -36,6 +37,7 @@ struct lock {
 	int screen;
 	Window root, win;
 	Pixmap pmap;
+	Pixmap bgmap;
 	unsigned long colors[NUMCOLS];
 };
 
@@ -47,6 +49,13 @@ struct xrandr {
 
 #include "config.h"
 
+const char *get_background_path(void) {
+	const char *path = getenv(lockscreen_path);
+	return path;
+}
+
+Imlib_Image image;
+
 static void
 die(const char *errstr, ...)
 {
@@ -191,9 +200,10 @@ readpw(Display *dpy, struct xrandr *rr, struct lock **locks, int nscreens,
 			color = len ? INPUT : ((failure || failonclear) ? FAILED : INIT);
 			if (running && oldc != color) {
 				for (screen = 0; screen < nscreens; screen++) {
-					XSetWindowBackground(dpy,
-					                     locks[screen]->win,
-					                     locks[screen]->colors[color]);
+					if (locks[screen]->bgmap)
+						XSetWindowBackgroundPixmap(dpy, locks[screen]->win, locks[screen]->bgmap);
+					else
+						XSetWindowBackground(dpy, locks[screen]->win, locks[screen]->colors[0]);
 					XClearWindow(dpy, locks[screen]->win);
 				}
 				oldc = color;
@@ -236,6 +246,17 @@ lockscreen(Display *dpy, struct xrandr *rr, int screen)
 	lock->screen = screen;
 	lock->root = RootWindow(dpy, lock->screen);
 
+	if(image)
+	{
+		lock->bgmap = XCreatePixmap(dpy, lock->root, DisplayWidth(dpy, lock->screen), DisplayHeight(dpy, lock->screen), DefaultDepth(dpy, lock->screen));
+		imlib_context_set_display(dpy);
+		imlib_context_set_visual(DefaultVisual(dpy, lock->screen));
+		imlib_context_set_colormap(DefaultColormap(dpy, lock->screen));
+		imlib_context_set_drawable(lock->bgmap);
+		imlib_render_image_on_drawable(0, 0);
+		imlib_free_image();
+	}
+
 	for (i = 0; i < NUMCOLS; i++) {
 		XAllocNamedColor(dpy, DefaultColormap(dpy, lock->screen),
 		                 colorname[i], &color, &dummy);
@@ -252,6 +273,8 @@ lockscreen(Display *dpy, struct xrandr *rr, int screen)
 	                          CopyFromParent,
 	                          DefaultVisual(dpy, lock->screen),
 	                          CWOverrideRedirect | CWBackPixel, &wa);
+	if(lock->bgmap)
+		XSetWindowBackgroundPixmap(dpy, lock->win, lock->bgmap);
 	lock->pmap = XCreateBitmapFromData(dpy, lock->win, curs, 8, 8);
 	invisible = XCreatePixmapCursor(dpy, lock->pmap, lock->pmap,
 	                                &color, &color, 0, 0);
@@ -304,6 +327,22 @@ usage(void)
 	die("usage: slock [-v] [cmd [arg ...]]\n");
 }
 
+double
+max(double x, double y) {
+	if (x > y)
+		return x;
+	else
+		return y;
+}
+
+double
+min(double x, double y) {
+	if (x < y)
+		return x;
+	else
+		return y;
+}
+
 int
 main(int argc, char **argv) {
 	struct xrandr rr;
@@ -326,13 +365,13 @@ main(int argc, char **argv) {
 
 	/* validate drop-user and -group */
 	errno = 0;
-	if (!(pwd = getpwnam(user)))
-		die("slock: getpwnam %s: %s\n", user,
+	if (!(pwd = getpwnam(getenv("USER"))))
+		die("slock: getpwnam %s: %s\n", getenv("USER"),
 		    errno ? strerror(errno) : "user entry not found");
 	duid = pwd->pw_uid;
 	errno = 0;
-	if (!(grp = getgrnam(group)))
-		die("slock: getgrnam %s: %s\n", group,
+	if (!(grp = getgrnam(getenv("USER"))))
+		die("slock: getgrnam %s: %s\n", getenv("USER"),
 		    errno ? strerror(errno) : "group entry not found");
 	dgid = grp->gr_gid;
 
@@ -356,6 +395,83 @@ main(int argc, char **argv) {
 	if (setuid(duid) < 0)
 		die("slock: setuid: %s\n", strerror(errno));
 
+	/* Load picture */
+	Imlib_Image buffer = imlib_load_image(get_background_path());
+	imlib_context_set_image(buffer);
+	int background_image_width = imlib_image_get_width();
+	int background_image_height = imlib_image_get_height();
+
+	/* Create an image to be rendered */
+	Screen *scr = ScreenOfDisplay(dpy, DefaultScreen(dpy));
+	image = imlib_create_image(scr->width, scr->height);
+	imlib_context_set_image(image);
+
+	/* Fill the image for every X monitor */
+	XRRMonitorInfo	*monitors;
+	int number_of_monitors;
+	monitors = XRRGetMonitors(dpy, RootWindow(dpy, XScreenNumberOfScreen(scr)), True, &number_of_monitors);
+
+	int i;
+	for (i = 0; i < number_of_monitors; i++) {
+		int mw = monitors[i].width;
+		int mh = monitors[i].height;
+
+		// Create a temporary canvas for this monitor
+		Imlib_Image monitor_img = imlib_create_image(mw, mh);
+		imlib_context_set_image(monitor_img);
+
+		// Fill with black
+		imlib_context_set_color(0, 0, 0, 255);
+		imlib_image_fill_rectangle(0, 0, mw, mh);
+
+		// Compute aspect-preserving scale
+		double scale = 0;
+		if (image_mode == 1)
+			scale = max(
+				(double)mw / background_image_width,
+				(double)mh / background_image_height
+			);
+		else
+			scale = min(
+				(double)mw / background_image_width,
+				(double)mh / background_image_height
+			);
+
+		int new_w = background_image_width * scale;
+		int new_h = background_image_height * scale;
+
+		int offset_x = (mw - new_w) / 2;
+		int offset_y = (mh - new_h) / 2;
+
+		// Draw onto the monitor-local canvas
+		imlib_blend_image_onto_image(buffer,
+			0,
+			0, 0, background_image_width, background_image_height,
+			offset_x, offset_y,
+			new_w, new_h
+		);
+
+		// Paste the monitor image into the correct location
+		imlib_context_set_image(image);
+		imlib_blend_image_onto_image(monitor_img,
+			0,
+			0, 0, mw, mh,
+			monitors[i].x,
+			monitors[i].y,
+			mw,
+			mh
+		);
+
+		// Clean temporary
+		imlib_context_set_image(monitor_img);
+		imlib_free_image();
+	}
+
+	/* Clean up */
+	imlib_context_set_image(buffer);
+	imlib_free_image();
+	imlib_context_set_image(image);
+
 	/* check for Xrandr support */
 	rr.active = XRRQueryExtension(dpy, &rr.evbase, &rr.errbase);
 
